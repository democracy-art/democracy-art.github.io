---
layout:     post
title:      定制的自动化攻击 - Chapter 14
subtitle:   
date:       2020-02-07
author:     D
header-img: 
catalog: true
mermaid: true
tags:
    - web hacking
---

参考:*The Web Application Hacker's Handbook* 
Chapter 14 Automating Customized Attacks

每个web应用程序都是不同的。有效地攻击应用程序涉及使用各种手动过程和技术来了解其行为并探测漏洞。
它还需要以一种富有想象力的方式来承载你的经验和直觉。攻击在本质上通常是定制的，针对您已经确定的特定行为以及应用程序使您能够与之交互和操作的特定方式进行定制。手动执行自定义攻击非常费力，而且容易出错。最成功的web应用程序黑客将他们的定制攻击更进一步，并找到使其自动化的方法，使其更容易、更快、更有效。

# 用于自定义自动化(Uses for Customized Automation)

在三种主要情况下，可以使用定制的自动化技术来帮助您攻击web应用程序:

- 枚举标识符(Enumerating identifiers)

大多数应用程序使用各种名称和标识符来引用数据和资源的单个项，如`帐号`、`用户名`和`文档id`。
您经常需要迭代大量的潜在标识符，以枚举哪些标识符是有效的或值得进一步研究的.
在这种情况下，您可以以完全定制的方式使用自动化来遍历可能的标识符列表，或者循环遍历应用程序相信正在使用的标识符的语法范围。
枚举标识符攻击的一个例子是，应用程序使用页码参数来检索特定的内容:
```
http://mdsec.net/app/ShowPage.ashx?PageNo=10069
```
在浏览应用程序的过程中，您会发现大量有效的PageNo值。但是要识别每个有效值，您需要遍历整个范围，这是手动无法做到的.<br>


- 收集数据(Harvesting data)

许多web应用程序漏洞使您能够使用特制的请求从应用程序中提取`有用`的或`敏感`的数据.
例如，一个人的profile page可以显示当前用户的`个人`信息和`银行`信息，并指示用户在应用程序中的`特权`级别。通过访问控制缺陷，您可以查看任何应用程序用户的个人简介页面，但一次只能查看一个用户。为每个用户收集这些数据可能需要数千个单独的请求。您可以使用定制的自动化攻击，而不是手动操作，从而以一种有用的形式快速捕获所有这些数据。获取有用数据的一个例子是扩展刚才描述的枚举攻击。
而不是简单地确定PageNo所看重的是否有效，您的自动攻击可以提取HTML的内容它检索的每个页面的标题标记，使您能够快速扫描列表为那些最有趣的页面。<br>

- Web应用程序模糊测试(Web application fuzzing)

检测常见web应用程序漏洞的最佳方法是提交各种各样的示例意外的数据项和攻击字符串，并检查应用程序的响应，以发现可能存在缺陷的任何异常。在大型应用程序中，您最初的映射练习可能会确定需要探测的几十个不同请求，每个请求都包含许多不同的参数。手动测试每个案例将是耗时和令人麻木的，并且可能会忽略大部分攻击面。然而，使用自定义自动化，您可以快速生成包含常见攻击字符串的大量请求，并快速评估服务器的响应，以在值得进一步研究的有趣案例中进行研究。这种技术通常被称为`fuzzing`。

# 枚举标识符(Enumerating identifiers)

我们已经描述了各种常见的漏洞和攻击技术，您已经遇到了许多应用程序对某些项使用名称或标识符的情况，作为攻击者，您的任务是发现使用中的部分或全部有效标识符。下面是一些可能出现此需求的示例.

- 应用程序的登录功能返回信息消息，关闭失败的登录是否是由于无法识别的用户名或不正确的密码。通过遍历常见用户名列表并尝试使用每个用户名登录，可以将列表缩小到您认为有效的用户名.然后可以将此列表用作密码猜测攻击的基础.

- 许多应用程序使用标识符来引用在应用程序中处理的单个资源，如文档id、帐号、员工编号和日志条目。
通常情况下，应用程序公开了一些确定特定标识是否有效的方法。通过遍历使用中的标识符的语法范围，您可以获得所有这些资源的全面列表。

- 如果可以预测由应用程序生成的会话令牌，则可以简单地从向您发出的一系列令牌推断出其他用户会话。根据此流程的可靠性，您可能需要为每个指定的有效值测试大量候选令牌。

## 基本方法(The Basic Approach)
制定一个定制的自动攻击以枚举有效的标识符时，您的首要任务是定位具有以下特征的request/response对:

- 请求包含一个参数，该参数包含目标标识符。例如，在显示应用程序页面的函数中，请求可能包含参数`PageNo=10069`.

- 当您改变参数s值时，服务器对这个请求的响应会以一种系统的方式变化。例如，如果请求一个有效的`PageNo`，服务器可能会返回一个包含指定文档内容的响应。如果请求了一个无效的值，它可能会返回一个通用的错误消息。

找到合适的请求/响应对后，基本的方法包括向应用程序提交大量的自动化请求，或者通过潜在的标识符列表进行工作，或者遍历已知正在使用的标识符的语法范围。应用程序对这些请求的响应将被监视，以获取`点击率`，这表明提交了一个有效的标识符。

## 检测命中(Detecting Hits)
有许多响应的属性可以检测到系统的变化，因此可以为自动攻击提供基础。

### HTTP状态码(HTTP Status Code)
许多应用程序以一种系统的方式返回不同的状态码对提交参数的值进行ing。最常见的值在枚举标识符的攻击过程中遇到的问题如下:

- 200 -- 默认状态码，表示`OK`
- 301 or 302 -- 重定向到另一个URL
- 401 OR 403 -- 请求未被授权或允许
- 404 -- 未找到请求的资源
- 500 -- 服务器在处理请求时遇到错误

### Response Length
动态应用程序页面通常使用页面模板构造响应(页面模板的长度是确定的)，并将每个响应的内容插入该模板。如果每个响应的内容不存在或无效(例如请求的文档ID不正确)，应用程序可能只返回一个空模板。在这种情况下，响应长度是一个可靠的指示器，用于判断是否标识了有效的文档ID。<br>
在其他情况下，不同的`响应长度`可能指向错误的发生或附加功能的存在。根据作者的经验，HTTP状态码和响应长度指示器已经被发现是在大多数情况下识别异常响应的高度`可靠`的方法。

### Response Body
应用程序实际返回的数据通常包含可用于检测命中的文字字符串或模式。例如，当请求无效的文档ID时，响应可能包含字符串`invalid document ID`。在某些情况下，HTTP状态代码没有变化，并且由于包含了动态内容，整个响应长度是可变的，因此搜索特定的字符串或模式的响应可能是识别命中的最可靠的方法。
### Location Header
在某些情况下，应用程序使用HTTP重定向(301或302状态码)响应特定URL的每个请求，重定向的目标取决于请求中提交的参数。例如，如果提供的报表名称正确，则查看报表的请求可能导致重定向到/download.jsp，如果提供的报表名称不正确，则重定向到/error.jsp。HTTP重定向的目标在Location头中指定，通常可以用来识别命中。

### Set-Cookie Header
偶尔，应用程序可能会以相同的方式响应任何一组参数，但在某些情况下会设置cookie。例如，每个登录请求可能会遇到相同的重定向，但是在有效凭证的情况下，应用程序设置一个包含会话token的cookie。客户端在重定向之后接收的内容取决于是否提交了有效的会话token。

### Time Delays
有时，在提交有效和无效参数时，服务器响应的实际内容可能是相同的，但是返回`响应的时间`可能略有不同。例如，当一个无效的用户名被提交给一个登录函数时，应用程序可能会立即响应一个通用的、不提供信息的消息。
然而，当提交了有效的用户名时，应用程序可能会执行各种后端处理来验证所提供的凭据(其中一些需要大量计算)，然后返回相同的消息(如果凭据不正确)。
<br>
如果您可以远程检测到这个时间差异，它可以作为一个鉴别器来识别您的攻击命中。(这个bug也经常出现在其他类型的软件中，比如较老版本的OpenSSH。)<br>

**TIP**
>选择命中指示灯的主要目标是找到一个完全可靠的或者找到一个组合在一起是可靠的指示灯。然而，在某些攻击中，您可能事先并不知道命中是什么样子的。例如，在针对登录函数尝试枚举用户名时，您可能实际上没有一个已知的有效用户名来确定在命中的情况下应用程序的行为。在这种情况下，最好的方法是监视应用程序对刚才描述的`所有属性`的响应，并查找`任何异常`。

## 脚本攻击(Scripting the Attack)
假设您已经标识了以下URL，当提交有效的PageNo值时，它将返回200个状态码，否则返回500个状态码:
```
http://mdsec.net/app/ShowPage.ashx?PageNo=10069
```
这个 request/response 对满足两个条件，这两个条件是您能够装入自动攻击来枚举有效的page IDs所必需的。
在这种简单的情况下，可以快速创建自定义脚本来执行自动攻击。例如，下面的bash脚本从标准输入中读取可能的页面ID列表，使用`netcat`工具请求包含每个ID的URL，并记录服务器响应的第一行，其中包含HTTP状态代码:
```
#!/bin/bash
server=mdsec.net
port=80
while read id
do
echo -ne “$id\t”
echo -ne “GET/app/ShowPage.ashx?PageNo=$id HTTP/1.0\r\nHost: $server\r\n\r\n”
| netcat $server $port | head -1 done | tee outputfile
```
使用适当的输入文件运行此脚本将生成以下输出，这使您能够快速识别有效的页面IDs:
```
~> ./script <IDs.txt
10060 HTTP/1.0 500 Internal Server Error
10061 HTTP/1.0 500 Internal Server Error
10062 HTTP/1.0 200 Ok
10063 HTTP/1.0 200 Ok
10064 HTTP/1.0 500 Internal Server Error
...
```
您可以在Windows批处理脚本中轻松地实现相同的结果。下面的示例使用`curl`工具生成请求，并使用`findstr`命令获取输出:
```
for /f “tokens=1” %i in (IDs.txt) do echo %i && curl
mdsec.net/app/ShowPage.ashx?PageNo=%i -i -s | findstr /B HTTP/1.0
```
类似这样的简单脚本非常适合执行简单的任务，比如遍历参数值列表和解析服务器对单个属性的响应。但是，在许多情况下，您可能需要比命令行脚本更强大的功能和更强的稳定性。作者的首选是使用合适的高级面向对象语言，这种语言支持对基于字符串的数据进行简单的操作，并为使用socket和SSL提供可访问的api。满足这些条件的语言包括Java、c#,GO和Python。我们将更深入地研究一个使用Java的示例。

# 收集有用的数据(Harvesting Useful Data)
在攻击应用程序时，自定义自动化的第二个主要用途是通过使用特定的精心设计的请求一次检索一项信息来提取有用的或敏感的数据。这种情况最常见的情况是，您发现了一个可利用的漏洞，例如访问控制缺陷，该缺陷允许您通过指定一个标识符来访问未经授权的资源。但是，当应用程序完全按照设计者的意图运行时，也可能出现这种情况.下面是一些自动化数据收集可能有用的例子:

- 在线零售应用程序包含注册客户查看其未完成订单的功能.然而，如果你能确定分配给其他客户的订单号，你就能像查看自己的订单信息一样查看他们的订单信息.

- 一个被遗忘的密码功能依赖于用户可信赖的挑战.您可以提交任意用户名并查看相关的挑战.通过遍历枚举或猜测的用户名列表，您可以获得大量用户密码挑战列表，以识别那些很容易猜测的用户名.

- 一个工作流应用程序包含一个函数，用于显示给定用户的一些基本帐户信息，包括其在应用程序中的特权级别。通过遍历所使用的用户id范围，可以获得所有管理用户的列表，可以将其用作猜测密码和其他攻击的基础。

使用自动化的基本方法获取数据本质上是类似于枚举有效的标识符,除了你现在不仅感兴趣一个二进制的结果(击中或错过)但也正试图提取一些可用的每个响应的内容形式。

考虑下面的请求，它是由登录用户发出的，以显示其帐户信息:
```
GET /auth/498/YourDetails.ashx?uid=198 HTTP/1.1
Host: mdsec.net
Cookie: SessionId=0947F6DC9A66D29F15362D031B337797
```
尽管只有通过身份验证的用户才能访问此应用程序功能，但是存在访问控制漏洞，这意味着任何用户都可以通过简单地修改`uid`参数来查看任何其他用户的详细信息。在进一步的漏洞中，披露的细节还包括用户的完整凭证。由于uid参数的值较低，所以应该很容易预测其他用户身份.

当显示用户详细信息时，页面源将个人数据包含在HTML表中，如下所示:
```
<tr>
<td>Name: </td><td>Phill Bellend</td>
</tr>
<tr>
<td>Username: </td><td>phillb</td>
</tr>
<tr>
<td>Password: </td><td>b3ll3nd</td>
</tr>
...
```
考虑到应用程序的行为，很容易安装一个定制的自动攻击来获取应用程序中包含的所有用户信息，包括凭据.可以自己写脚本,写Java插件或利用现有的工具获取.

# 常见漏洞的模糊化(Fuzzing for Common Vulnerabilities)

定制自动化的第三个主要用途不涉及针对任何已知的漏洞来枚举或提取信息.相反,您的目标是通过各种精心设计的攻击字符串来探测应用程序,以在应用程序中`引起异常`行为,如果存在特殊的常见漏洞.这种类型的攻击远没有前面描述的那样集中，原因如下:

- 它通常涉及将一组攻击有效载荷作为每个参数提交到应用程序的每个页面，而不考虑每个参数的正常功能或应用程序期望接收的数据类型。这些有效载荷有时被称为fuzzing strings.

- 你不提前知道如何精确的识别命中.您通常需要以清晰的形式捕获尽可能多的细节，而不是监视应用程序的响应以获得特定的成功指标.然后，您可以轻松地查看这些信息，以确定哪些情况下您的攻击字符串在应用程序中触发了一些异常行为，值得进一步研究.

正如您在检查各种常见的web应用程序缺陷时所看到的，一些缺陷以特定的可识别方式在应用程序的行为中表现出来，比如一条特定的错误消息或HTTP状态码.有时可以依赖这些漏洞签名来检测常见的缺陷，它们是自动应用程序漏洞扫描器识别其大部分缺陷的方法.但是，原则上，您提交给应用程序的任何测试字符串都可能导致任何预期的行为，在其特定上下文中，这些行为指向漏洞的存在.**因此，使用定制的自动化技术的有经验的攻击者通常比任何完全自动化的工具更有效。**

在前面的例子中已经识别并利用了被破坏的访问控制，我们还可以执行一个模糊攻击来检查各种基于输入的漏洞。作为对攻击面的初步探索，我们决定在每个参数中依次提交以下字符串:

- `'` --这将在SQL注入的某些实例中生成一个错误.
- `;/bin/ls` --此字符串在某些命令注入情况下会导致意外行为.
- `../../../../../etc/passwd` --在存在路径遍历的情况下，此字符串会导致不同的响应.
- `xsstest` --如果将此字符串复制到服务器的响应中，应用程序可能容易受到跨站点脚本攻击.

我们可以通过创建新的有效负载源来扩展JAttack工具来生成这些有效负载.

**NOTE**
>任何探测安全缺陷应用程序的严重攻击都需要使用许多其他攻击字符串来识别其他弱点和前面提到的缺陷的其他变体

首先利用 Java 写好 Payload.下一个任务是手动检查JAttack的输出，并尝试识别任何可能表明存在漏洞的异常结果:

|param|payload|status|length||
|-|-|-|-|-|
|SessionId|`'`|302|502||
|SessionId| `;/bin/ls`| 302| 502||
|SessionId| `../../../../../../etc/passwd`| 302| 502||
|SessionId| `xsstest`| 302 |502||
|uid |`'` |200 |2941 |exception quotation|
|uid |`;/bin/ls` |200| 2895 |exception|
|uid |`../../../../../../etc/passwd`| 200| 2915| exception|
|uid |`xsstest`| 200| 2898| exception xsstest|

在修改SessionId参数的请求中，应用程序将使用具有相同长度的重定向响应进行响应.这种行为并不表示任何漏洞这并不奇怪，因为在登录时修改会话令牌通常会使当前会话无效，并导致重定向到登录.

uid参数更有趣.对该参数的所有修改都会导致包含字符串`exception`的响应.**响应的长度是可变的，这表明不同的有效负载会导致不同的响应，所以这可能不仅仅是一个通用的错误消息.**更进一步，我们可以看到，当提交单引号时，应用程序的响应包含字符串引号，它可能是SQL错误消息的一部分。这可能是一个SQL注入fl aw，我们应该手动调查来确定这(见第9章).此外，我们可以看到负载xsstest在应用程序的响应中被回显.我们应该进一步探测这种行为，以确定是否可以利用错误消息来执行跨站点脚本攻击(参见第12章).

# 综上所述:Burp Intruder(Putting It All Together: Burp Intruder)

`Burp Suite` 里面的 `Intruder` 模块能实现定制的自动化攻击.
步骤:
## 1.确定Payloads位置(Positioning Payloads)
如:
```
POST /auth/459/NewUserStep2.ashx?mode=prod HTTP/1.1
...

realname=rx1&username=rose&password=iloveyou&cardnum=123456
```
Payloads位置可以确定为: `rose` 和 `iloveyou`.

## 2.选择Payloads(Choosing Payloads)<br>
入侵者包含许多用于生成攻击有效负载的内置函数，包括以下内容:

- 预设和配置项目列表
- 定制可迭代的基于任意语法结构的Payloads.比如,程序使用usernames的格式为 ABC45D,这个自定义的迭代器可用于循环遍历所有可能的用户名.
- 字符串和大小写替换.比如,字符串 password 能被改成 p4ssword , passw0rd , Password , PASSWORD 等等.
- 数字，可以用来循环遍历文档id、会话token等等.
- 日期, 在某些情况下, 可以和数字一样使用.
- 非法 Unicode 编码, 可以通过提交恶意可选的编码字符来绕过过滤器.
- 字符块, 可以用来检测缓冲区溢出.
- 一个暴力破解函数, 可以用来生成特定长度范围内的特定字符集的所有排列.
- 字符重组和位翻转

## 3.Configuring Response Analysis
分析返回的Response内容:
- HTTP 状态码
- response 的长度
- cookies 
- 返回response所花的时间
- ...

## 4.攻击 例1:枚举标识符
假设您的目标是一个支持匿名用户自注册的应用程序.您创建一个帐户，登录，并获得最低限度的功能访问.在此阶段，一个明显感兴趣的领域是应用程序的会话标记.连续几次登录会产生连续下降的结果:
```
000000-fb2200-16cb12-172ba72551
000000-bc7192-16cb12-172ba7279e
000000-73091f-16cb12-172ba729e8
000000-918cb1-16cb12-172ba72a2a
000000-aa820f-16cb12-172ba72b58
000000-bc8710-16cb12-172ba72e2b
```
很明显，大约一半的令牌没有改变，但是您还会发现令牌的第二部分实际上也没有被应用程序处理.完全修改这部分并不会使您的令牌失效.此外，虽然它不是连续的，但最后一部分显然以某种方式递增.这看起来是一个很有希望的会话劫持攻击机会.<br>
<br>
为了利用自动化来交付这种攻击，您需要找到一个可以用来检测有效令牌的request/response对.通常，对应用程序的已验证页面的任何请求都将满足此目的.您决定以登录后呈现给每个用户的页面为目标:
```
GET /auth/502/Home.ashx HTTP/1.1
Host: mdsec.net
Cookie: SessionID=000000-fb2200-16cb12-172ba72551
```
由于您已经了解了会话令牌的结构和处理，因此您的攻击只需要修改令牌的最后一部分.实际上，由于所标识的序列，最有效的初始攻击只修改令牌的最后几个数字(比如,三位数).如下:<br>
Burp的标签 <kbd>intruder</kbd>--><kbd>position</kbd>:<br>
attack type:sniper <br>
payload position: <br>
```
...
SessionID=000000-fb2200-16cb12-172ba72$551$
...
```
您的有效载荷需要序列通过所有可能的值为最后三位数.该标记似乎使用与十六进制数字相同的字符集:`0到9`和`a到f`.因此，您可以确定一个有效负载源来生成从`0x000`到`0xfff`范围内的所有十六进制数.
即 :
Burp的标签 <kbd>intruder</kbd>--><kbd>payloads</kbd>:<br>
payload set:1 | number <br>
**range**&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;**format**<br>
from <input type="text" value=0 maxlength="5"> min integer digits <input type="text" value=3 maxlength="3"><br>
to <input type="text" value=fff maxlength="5"> min integer digits <input type="text" value=3 maxlength="3"><br>
step <input type="text" value=1 maxlength="5"><br>

在枚举有效会话标记的攻击中，标识命中通常很简单.在本例中，您已经确定应用程序在提供有效令牌时返回`HTTP 200`响应，在提供无效令牌时返回`HTTP 302`重定向到登录页面.因此，您不需要为这种攻击提供任何定制的响应分析.<br><br>

发起攻击会导致入侵者快速遍历请求。攻击结果以表的形式显示。您可以`单击`每个`列标题`，根据该列的内容对`结果`进行`排序`。根据状态代码进行排序使您能够轻松地识别所发现的有效token.您还可以使用`results`窗口中的筛选和搜索功能来帮助在大量结果中定位感兴趣的项.<br><br>

攻击成功了。您可以使用任何导致HTTP的有效负载200个响应，用它替换会话令牌的最后三位数，从而劫持其他应用程序用户的会话.然而，仔细看看结果表。大多数HTTP 200响应具有大致相同的响应长度，因为呈现给不同用户的主页或多或少是相同的.然而，其中两个响应要长得多，这表明返回了一个不同的主页.<br><br>

您可以在入Intruder中双击一个结果项，以完整显示服务器的响应，可以是原始HTTP，也可以是HTML。这样做表明，`较长`的主页比您的主页包含更多的菜单选项和不同的细节。这两个被劫持的会话似乎属于拥有`更多特权`的用户。<br><br>

**TIP**
>响应`长度`通常是异常响应的一个强有力的指标，值得进一步研究.与前面的情况一样，不同的响应长度可能会导致一些有趣的差异，这些差异可能是您在设计攻击时没有预料到的.因此，即使另一个属性提供了可靠的点击率指示，例如HTTP状态码，您也应该始终检查响应长度列，以识别其他有趣的响应.

## 5.攻击 例2:收集信息
进一步浏览应用程序的认证区域时，您会注意到它在URL参数中使用索引号来标识用户请求的函数.
例如，下面的URL用于显示当前用户的My Details页面:
```
https://mdsec.net/auth/502/ShowPage.ashx?pageid=32010039
```
这种行为提供了一个很好的机会,在您可能没有得到适当的授权情况下,来搜索您尚未发现的功能.为此，您可以使用Burp Intruder来循环遍历一系列可能的pageid值并提取找到的每个页面的标题.<br>

在这种情况下，开始搜索已知包含有效值的数值范围内的内容通常是明智的.为此，可以将有效载荷位置标记设置为以pageid的最后两位数字为目标,并在`00`到`99`范围内产生有效载荷.<br>

您可以使用Extract Grep函数从每个响应捕获页面title.通过如下:<br>
Burp的标签:<br>
<kbd>intruder</kbd>--><kbd>options</kbd>--><kbd>extract</kbd>
然后勾选及填写内容如下:<br>
* [x] capture text following these expressions:<br>
<input type=text value="<title>"/><input type=radio value=1 checked> simple pattern match
* [x] exclude HTTP headers 
stop capturing at <input type=text value="<">
max capture length <input type=text value="100">

发起此攻击将快速遍历pageid参数最后两位的所有可能值，并显示每个响应的页面标题.一些响应似乎包含有趣的管理功能。此外，一些回复是重定向到一个不同的URL，这保证了进一步的调查.如果您愿意，您可以重新确认您的Intruder攻击来提取这些方向的目标，或者甚至自动跟踪它们并从最终响应中显示页面标题.<br>

## 6.攻击 例3:应用程序模糊测试(Application Fuzzing)
除了利用已经发现的bug之外，当然还应该探测目标应用程序的常见漏洞.为了确保适当的覆盖率，您应该测试`每个参数`和`请求`，从登录请求开始。<br><br>

要对给定请求执行快速模糊测试，需要在所有请求参数上设置有效负载位置。只需单击“位置”选项卡上的“自动”按钮即可完成此操作.<br>

然后，您需要确定一组攻击字符串来用作有效负载和一些常见的错误消息来搜索响应.Intruder包含用于这两种用途的内置字符串集。<br>

与使用JAttack执行的模糊攻击一样，您需要手动检查结果表，以确定任何值得进一步研究的异常.与前面一样，您可以单击列标题，以各种方式对响应进行排序，以帮助识别有趣的案例.<br>

从最初的结果来看，应用程序很容易受到SQL注入的影响.在这两个有效负载位置，当提交单引号时，应用程序返回一个不同的响应，其中包含一个消息，其中包含字符串、引号和语法.这种行为理所当然地需要一些手动调查来确定和利用漏洞.<br>

# 自动化的障碍(Barriers to Automation)

自动化的障碍通常分为两类:

- 会话处理机制，防御性地终止会话以响应意外请求，使用短暂的参数值，如每个请求都会更改的anti-CSRF令牌(参见第13章)，或涉及多阶段进程.
- CAPTCHA控件用于防止自动化工具访问特定的应用程序功能，例如注册新用户帐户的功能.

我们将研究每一种情况,并描述您通过改善您的自动化工具或发现应用程序的防御漏洞,绕过障碍以实现自动化的方法.

## 会话处理机制(Session-Handling Mechanisms)

许多应用程序使用会话处理机制和其他有状态的功能，这些功能可能会为自动化测试带来问题.以下是一些可能出现障碍的情况:<br>

- 当您测试一个请求时，应用程序会终止用于测试的会话，或者出于防御的原因，或者出于其他原因，其余的测试活动是无效的.
- 应用程序函数使用必须与每个请求一起提供的更改令牌(例如，以防止请求伪造攻击)。
- 被测试的请求出现在一个多阶段流程中.只有在发出一系列其他请求以使应用程序进入适当的状态时，才会正确地处理请求.

这类障碍在原则上总是可以通过调整你的自动化技术，使之与应用程序所使用的任何机制一起工作来绕过。正在编写自己的测试代码的JAttack，您可以直接实现对特定的令牌处理或多级机制的支持。但是，这种方法可能很复杂，并且不能很好地扩展到大型应用程序。在实践中，需要编写新的自定义代码来处理问题的每个新实例本身可能会对使用自动化造成很大的障碍，而且您可能会发现自己又回到了较慢的手动技术。

## 在Burp套件中提供会话处理支持(Session-Handling Support in Burp Suite)

幸运的是，Burp套件提供了一系列的特性，以尽可能轻松的方式处理所有这些情况，允许您在此期间继续进行测试
Burp在后台无缝处理障碍.这些功能是基于以下组件:

- Cookie jar
- Request macros
- Session-handling rules

我们将简要地描述如何结合这些特性来克服自动化的障碍，并允许您在各种描述的现场继续测试.更多详细的帮助可以在Burp套件的在线文档中找到。

### Cookie jar

Burp套件维护自己的cookie jar，它跟踪浏览器使用的应用程序Cookie和Burp自己的工具使用的应用程序cookie。您可以确定如何自动地更新Cookie jar，您也可以查看和直接编辑其内容.<br>
本身，cookie jar实际上什么也不做，但是它跟踪的键值可以在Burp的会话处理支持的其他组件中使用.

### Request Macros
宏是一个或多个请求的预先定义的序列。宏可用于执行各种与会话相关的任务，包括以下内容:

- 获取应用程序的页面(例如用户的主页)以检查当前会话是否仍然有效
- 执行登录以获得新的有效会话
- 获取令牌或nonce以在另一个请求中用作参数
- 当在一个多步骤的过程中扫描或模糊一个请求时，执行必要的前面的请求，使应用程序进入一个目标请求将被接受的状态，使用浏览器记录宏。当修改宏时，Burp显示代理历史的视图，您可以从中选择要用于宏的请求。您可以从以前发出的请求中进行选择，或者重新记录宏并从历史记录中选择新项.
- 是否应该将来自cookie jar的cookie添加到请求中
- 是否将响应中收到的cookie添加到cookie jar中
- 对于请求中的每个参数，它应该使用一个预置值还是从宏中的前一个响应派生的值

从之前的宏响应中获取参数s值的能力在某些多阶段进程和应用程序大量使用anti-CSRF tokens的情况下特别有用.当您设置一个新的宏时，Burp会通过识别参数来自动查找这类关系，这些参数的值可以从前面的响应中确定(如fi值、重定向目标、链接中的查询字符串).

### 会话处理规则(Session-Handling Rules)

Burp套件的session-handling支持的关键组件是消除会话处理规则的功能，这些规则利用cookie jar和请求宏来处理自动化的特殊障碍.<br>
每个规则包含一个范围(规则适用于什么)和操作(规则做什么).对于Burp发出的每个传出请求，它将确定哪些定义的规则在请求的范围内，并按顺序执行所有这些规则操作.<br>
每个规则的范围可以基于正在处理的请求的任何或所有以下特性来确定:

- 正在发出请求的Burp工具
- 请求的URL
- 请求中参数的名称

每个规则可以执行一个或多个操作，包括以下内容:

- 从会话处理cookie jar中添加cookie
- 设置一个指定的cookie或参数值
- 检查当前会话是否有效，并对结果执行相应的子操作
- 运行一个宏
- 提示用户进行浏览器内会话恢复

所有这些操作都是高度可配置的，可以以任意方式组合来处理几乎任何会话处理机制.运行宏并根据结果更新指定的cookie和参数值允许您在注销时自动重新登录到应用程序。能够提示浏览器内的会话恢复使您能够使用登录机制，包括从物理令牌键入数字或解决CAPTCHA难题.

## 验证码控制(CAPTCHA Controls)
...
### 攻击验证码的实现(Attacking CAPTCHA Implementations)

- 谜题图像是通过一个URL加载的，该URL将解决方案作为参数包含在内，或者将图像名称设置为CAPTCHA解决方案
- 谜题解决方案以隐藏的形式保存
- 迷惑解决方案出现在HTML注释或其他位置中，用于调试

**NOTE**
>一些应用程序故意使用代码路径来绕过
CAPTCHA允许某些经过授权的自动化过程使用。在这些情况下，通常可以通过不提供相关的参数名来绕过CAPTCHA.

## 自动解决验证码谜题(Automatically Solving CAPTCHA Puzzles)

对于涉及扭曲单词的标准谜题，解决谜题需要以下步骤:<br>
1.从图像中去除噪声<br>
2.图像分割成单独的字母<br>
3.每段文字的识别<br>

### 用人类的解决者(Using Human Solvers)

要解决大量验证码谜题的罪犯有时会使用在web应用程序安全测试环境中不适用的技术:

- 一个表面上良性的网站可以用来诱导人类验证码代理来解决从目标应用程序传递过来的谜题。通常情况下，攻击者会通过提供竞赛奖品或免费访问色情内容来引诱用户。当用户完成注册表单时，他将看到一个CAPTCHA谜题，这个谜题是实时从目标应用程序获取的。当用户解决了难题时，他的解决方案将被传递到目标应用程序。

- 在发展中国家，攻击者可以付费使用人类验证码无人机来解决大量谜题。一些公司提供这项服务，每解决1000个难题花费不到1美元。

# 总结
当您攻击web应用程序时，大多数必要的任务都需要根据该应用程序的行为和它使您能够与之交互和操作的方法进行调整。因此，您常常需要自己手动工作，提交单独的请求并检查应用程序的响应.<br>

本章描述的技术在概念上是直观的。它们涉及到利用自动化来使这些定制的任务更容易、更快、更有效。使用您自己的计算机的能力和可靠性来攻击您的目标的缺陷和弱点，实际上可以自动化您希望执行的任何手动过程。<br>

在某些情况下，会有一些障碍妨碍你直接应用自动化技术。不过，在大多数情况下，这些问题可以通过重新安装自动化工具或发现应用程序防御中的弱点来解决.<br>

虽然概念上很简单，但是有效地使用定制的自动化需要经验、技能和想象力。您可以使用工具来帮助，也可以自己编写。但是，没有什么可以替代智能的人工输入，它将真正有成就的web应用程序黑客与仅仅是业余爱好者区分开来。当您掌握了其他章节中描述的所有技术之后，您应该回到这个主题，并实践定制自动化可以用于应用这些技术的不同方法。<br>
