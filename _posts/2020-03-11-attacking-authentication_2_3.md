---
layout:		post
title:		Chapter 6 Attacking Authentication(2) - Design Flaws in Authentication Mechanisms(3)
subtitle:	
date:		2020-03-11
author:		D
header-img:
catalog:	true
mermaid:	true
tags: [web hacking]
---

参考: *The Web Application Hacker's Handbook* Chapter 6

# 1."记住我"功能(“Remember Me” Functionality)

应用程序通常会实现“记住我”功能，以方便用户使用。 这样，用户无需在每次通过特定计算机使用该应用程序时都重新输入用户名和密码。 这些功能通常在设计上是不安全的，并且使用户容易受到本地和其他计算机上用户的攻击：
- 某些“记住我”功能是使用简单的**持久性Cookie**来实现的，例如RememberUser = daf（请参见图6-6）。 当此cookie提交到初始应用程序页面时，该应用程序信任该cookie以验证用户身份，并绕过登录为该人创建一个应用程序会话。 攻击者可以使用公用或枚举用户名的列表来获得对应用程序的完全访问权限，而无需任何身份验证。

![figure6-6](/img/web_hacking/twahh/figure6-6.jpg)

- 一些“记住我”功能设置了一个cookie，该cookie不包含用户名，而是一种持久会话标识符，例如RememberUser = 1328。 将标识符提交到登录页面后，应用程序将查找与其关联的用户，并为该用户创建一个应用程序会话。 与普通会话令牌一样，如果可以预测或推断其他用户的会话标识符，则攻击者可以遍历大量潜在标识符来查找与应用程序用户关联的那些，因此无需身份验证即可访问其帐户 。 有关执行此攻击的技术，请参见第7章。

- 即使为重新标识用户而存储的信息受到了适当的保护（**加密**）以防止其他用户确定或猜测它，该信息仍可能易于通过**跨站点脚本**（请参阅第12章）之类的错误或漏洞捕获。 对用户计算机具有本地访问权限的攻击者。

**HACK STEPS**
- 1.激活任何“记住我”功能，并确定该功能是否确实可以完全“记住”用户，或者是否仅记住其用户名并在随后的访问中仍要求他输入密码。 如果是后者，则该功能不太可能暴露任何安全漏洞。
- 2.仔细检查设置的所有持久性Cookie，以及其他在其他本地存储机制中持久保存的数据，例如Internet Explorer的userData，Silverlight隔离存储或Flash本地共享对象。 寻找任何已保存的数据，这些数据可以明确标识用户或看起来包含用户的某些可预测标识符。
- 3.即使在存储的数据似乎被严重编码或混淆的地方，也应仔细检查。 比较“记住”几个非常相似的用户名和/或密码的结果，以识别对原始数据进行反向工程的任何机会。 在这里，请使用第7章中介绍的相同技术来检测会话令牌中的含义和模式。
- 4.尝试修改持久性cookie的内容，以使该应用程序相信另一个用户已将其详细信息保存在您的计算机上。

# 2.用户模拟功能(User Impersonation Functionality)

某些应用程序为该应用程序的特权用户实现了便利，以模仿其他用户，以便在其用户上下文中访问数据并执行操作。 例如，某些银行业务应用程序允许服务台操作员口头认证电话用户，然后将他们的应用程序会话切换到该用户的上下文中，以为他或她提供帮助。

模拟功能通常存在各种设计缺陷：
- 1.它可以实现为“隐藏”功能，不受适当的访问控制。 例如，任何知道或猜测URL `/admin/ImpersonateUser.jsp`的人都可以使用该功能并模拟其他任何用户（请参见第8章）。
- 2.当确定用户是否正在执行模拟时，应用程序可以信任用户可控制的数据。 例如，除了有效的会话令牌外，用户还可以提交cookie，以指定其会话当前正在使用哪个帐户。 攻击者可能无需经过身份验证即可修改此值并获得对其他用户帐户的访问权限，如图6-7所示。
- 3.如果应用程序允许模拟管理用户，则模拟逻辑中的任何弱点都可能导致垂直特权提升漏洞。 攻击者不仅可以获取对其他普通用户数据的访问权，还可以完全控制该应用程序。
- 4.一些模拟功能被实现为简单的“后门”密码，可以将其与任何用户名一起提交到标准登录页面以进行身份验证。 这种设计由于许多原因是高度不安全的，但是对于攻击者来说，最大的机会是，他们在执行标准攻击（例如登录的强行执行）时可能会发现此密码。 如果后门密码在用户实际密码之前匹配，则攻击者很可能会发现后门密码的功能，因此可以访问每个用户的帐户。 同样，暴力攻击可能导致两个不同的“命中”，从而显示后门密码，如图6-8所示。

![figure6-7](/img/web_hacking/twahh/figure6-7.jpg)

**HACK STEPS**
- 1.识别应用程序中的任何模拟功能。 如果未与发布的内容明确链接，则仍可以实施（请参见第4章）。
- 2.尝试直接使用模拟功能来模拟其他用户。
- 3.尝试操纵由模拟功能处理的任何用户提供的数据，以模拟其他用户。 请特别注意在非常规登录期间提交用户名的任何情况。
- 4.如果您成功使用了该功能，请尝试模拟任何已知或猜测的管理用户来提升特权。
- 5.在进行猜测密码的攻击时（请参阅“强行登录”部分），检查是否有任何用户似乎拥有多个有效密码，或者特定密码是否已与多个用户名匹配。 另外，使用在暴力攻击中捕获的凭据登录尽可能多的不同用户，然后查看一切是否正常。 请密切注意任何“以X身份登录”状态消息。

![figure6-8](/img/web_hacking/twahh/figure6-8.jpg)

# 3.凭证验证不完整(Incomplete Validation of Credentials)

精心设计的身份验证机制会对密码提出各种要求，例如**最小长度**或同时存在**大**写和**小**写字符。 相应地，某些设计不当的身份验证机制不仅不会强制执行这些良好做法，而且也没有考虑到用户自己为遵守这些规定所做的尝试。

例如，某些应用程序会截断密码，因此仅验证前n个字符。 某些应用程序对密码执行不区分大小写的检查。 一些应用程序在检查密码之前会删除不寻常的字符（有时以执行输入验证为借口）。 近年来，这类行为已在某些令人惊讶的高性能Web应用程序中得到识别，这通常是好奇的用户反复试验的结果。

这些对密码验证的限制中的每一个都会将可能的密码集中可用的变体数量减少一个数量级。 通过实验，您可以确定密码是否已被完全验证或任何限制是否有效。 然后，您可以微调针对登录的自动攻击，以删除不必要的测试用例，从而大大减少破坏用户帐户所需的请求数量。

**HACK STEPS**
- 1.使用您控制的帐户，尝试使用自己的密码进行登录：删除最后一个字符，更改字符的大小写以及删除任何特殊的印刷字符。 如果这些尝试中的任何一个成功，请继续尝试以了解实际正在进行的验证。
- 2.将所有结果反馈到您的自动密码猜测攻击中，以删除多余的测试用例并提高成功的机会。


[Chapter 6 Attacking Authentication(2) - Design Flaws in Authentication Mechanisms(2)](https://dm116.github.io/2020/03/11/attacking-authentication_2_2/)<br>
[Chapter 6 Attacking Authentication(2) - Design Flaws in Authentication Mechanisms(4)](https://dm116.github.io/2020/03/12/attacking-authentication_2_4/)
